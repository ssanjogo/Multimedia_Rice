{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multimedia_Rice","text":""},{"location":"#description","title":"Description","text":"<p>The idea of this code is to do a Rice encoder. </p> <p>For the algorithm we need a value M that will be a power of 2 and a value N taht will be the number to codify.     - We have to calculate the sign of the number N. If the number is positive or 0 we will write the sign as 1, if the number is negative we will write the number as 0.      - The second step is to calculate the quotient by dividing the absolute value of the number divided by the number M.      - The reminder is the absolut value of the number N mod M. </p> <p>So in order to generate the code we have to write the &lt; sign &gt; &lt; quotient &gt; &lt; reminder &gt;.</p>"},{"location":"#work-to-develop","title":"Work to develop","text":"<p>a) How many bits are needed to encode all integers between -1023 and +1023 (in natural binary encoding with a sign bit)?</p> <p>b) Calculate the Rice code for all integers N between -1023 and +1023 with M = 32.</p> <p>c) For what range of values of N does the Rice code require fewer bits than the natural binary encoding with a sign bit necessary to represent the entire range between -1023 and +1023? If the majority of data to be encoded belongs to this range (optimal input range), the use of Rice code will be advisable (there will be a bit savings). What is the maximum bit savings?</p> <p>d) For what value of M does the optimal input range extend between -255 and +255? What is the maximum bit savings now?</p> <p>e) What is the largest value of M that allows achieving a maximum savings of up to 6 bits? What is the optimal input range now?</p>"},{"location":"#execution-of-the-code","title":"Execution of the code","text":"<p>First you have to install the requirements.txt located in the main directory using this code: </p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>To run the code you have to go to the folder that contains the main.py, in this case the address of this folder is: MULTIMEDIA_RICE/src/ and in this directory we will find the main.py The next step is to execute the main.py file using the command:</p> <pre><code>python main.py\n</code></pre> <p>*Maybe you have to use python3 instead of python. </p>"},{"location":"#execution-of-the-documentation","title":"Execution of the documentation","text":"<p>To run the documentation using mk you must do the following, from the root folder:</p> <p>Important: you must install the requirements first.</p> <pre><code>mkdocs build\n\n\nmkdocs serve\n</code></pre> <p>When you run the serve, you will get the web page address on the command line, so you have to open it on your browser. </p>"},{"location":"#developed-by","title":"Developed by","text":"<ul> <li>Oscar Blazquez Jimenez</li> <li>Sara San Jos\u00e9 G\u00f3mez</li> </ul>"},{"location":"main/","title":"Main-Task","text":"<p>In the main class we implemented different methods in order to answer the tasks that we are asked on the exercice.</p> <p>handler: python</p>"},{"location":"main/#src.main.bitsNeedToCodify","title":"<code>bitsNeedToCodify(fNum, sNum)</code>","text":"<p>Method to calculate the number ob bits necessary to encode all the numbers between a  range (fNumb, sNumb), in a natural binary encode. </p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>fNum(int</code> <p>first number from where we want to codify, should be the bigest one. </p> required <code>-</code> <code>sNum(int</code> <p>second number to where we want to codify, should be the smallest one. </p> required <p>Return:      - nBits(int): number of bits to do the encode.</p> Source code in <code>src/main.py</code> <pre><code>def bitsNeedToCodify(fNum, sNum):\n    '''\n    Method to calculate the number ob bits necessary to encode all the numbers between a \n    range (fNumb, sNumb), in a natural binary encode. \n\n    Args:\n        - fNum(int): first number from where we want to codify, should be the bigest one. \n        - sNum(int): second number to where we want to codify, should be the smallest one. \n    Return: \n        - nBits(int): number of bits to do the encode. \n    '''\n\n    if (abs(fNum) &gt;= abs(sNum)):                                    # Check if the absolute value of the first number is bigger or equal than the absolute value of the second number.   \n        nBits = len(rice.calculNaturalBinaryBits(fNum)) + 1         # If the first number is bigger we calculate the number of bits of the value + 1 (the sign + or -)\n    else:                                                           # Check if the absolute value of the second number is smaller than the first one. \n        nBits = len(rice.calculNaturalBinaryBits(sNum)) + 1         # Calculate the number of bits of the second number + 1 (the sign + or -)\n\n    return nBits\n</code></pre>"},{"location":"main/#src.main.calculateRiceEncodedRange","title":"<code>calculateRiceEncodedRange(num1, num2, M)</code>","text":"<p>Method to calculate the Rice code for all the integer numbers from num1 to num2 with a specific M.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>num1(int</code> <p>firs limit number.</p> required <code>-</code> <code>num2(int</code> <p>second limit number. </p> required <code>-</code> <code>M(int</code> <p>Integer value, power of 2, necessary to the encode.</p> required <p>Returns:</p> Type Description <ul> <li>listEncodedRice(list): A list of tuples, where the first value is the decimal                       number and the second value is the encoded number with Rice.                       The first element of the list is the value M</li> </ul> Source code in <code>src/main.py</code> <pre><code>def calculateRiceEncodedRange(num1, num2, M):\n    '''\n    Method to calculate the Rice code for all the integer numbers from num1 to num2 with a specific M.\n\n    Args:\n        - num1(int): firs limit number.\n        - num2(int): second limit number. \n        - M(int): Integer value, power of 2, necessary to the encode.\n\n    Returns:\n        - listEncodedRice(list): A list of tuples, where the first value is the decimal \n                                 number and the second value is the encoded number with Rice. \n                                 The first element of the list is the value M\n    '''\n    listEncodedRice = []\n    listEncodedRice.append(M)\n\n    for num in range(min(num1, num2), max(num1, num2) + 1):\n        listEncodedRice.append((num, rice.encodeRice(M, num)))\n\n    return listEncodedRice\n</code></pre>"},{"location":"main/#src.main.checkBits","title":"<code>checkBits(listEncodedRice)</code>","text":"<p>Method to check if the compression with Rice is optimal or is not. </p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>listEncodedRice(list</code> <p>A list of tuples, where the first value is the decimal                       number and the second value is the encoded number with Rice.                       The first element of the list is the value M</p> required <p>Returns:     - optimalNumbers(list): List wit the numbers that are optimal compressed with Rice algorithm,                              so the length of the encoded number is smaller that the natural binary number.</p> Source code in <code>src/main.py</code> <pre><code>def checkBits(listEncodedRice):\n    '''\n    Method to check if the compression with Rice is optimal or is not. \n\n    Args:\n        - listEncodedRice(list): A list of tuples, where the first value is the decimal \n                                 number and the second value is the encoded number with Rice. \n                                 The first element of the list is the value M\n    Returns:\n        - optimalNumbers(list): List wit the numbers that are optimal compressed with Rice algorithm, \n                                so the length of the encoded number is smaller that the natural binary number.\n    '''\n\n    optimalNumbers = []\n    M = listEncodedRice[0]\n\n    for (num, encodedNum) in listEncodedRice[1::]:\n        naturalBinaryNum = rice.calculNaturalBinaryBits(num)\n        if (len(encodedNum) &lt; len(naturalBinaryNum)):\n            optimalNumbers.append(num)\n\n    return optimalNumbers\n</code></pre>"},{"location":"riceFunctions/","title":"Rice Functions","text":"<p>On this page you will find the methods used to code Rice.</p> <p>handler: python</p>"},{"location":"riceFunctions/#src.RiceFunctions.riceFunctions.calculNaturalBinaryBits","title":"<code>calculNaturalBinaryBits(num, M=-1)</code>","text":"<p>Method to calculate the bits needed to represent a number in natural binary.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>num(int</code> <p>Value to be converted to natural binary. </p> required <code>-</code> <code>M(int</code> <p>Power of 2 value. This will specify the number of bits of the Rice codification for the remainder. </p> required <p>Returns:</p> Type Description <ul> <li>string: natural binary string of the number.</li> </ul> Source code in <code>src/RiceFunctions/riceFunctions.py</code> <pre><code>def calculNaturalBinaryBits(num, M = -1):\n    '''\n    Method to calculate the bits needed to represent a number in natural binary.\n\n    Args:\n        - num(int): Value to be converted to natural binary. \n        - M(int): Power of 2 value. This will specify the number of bits of the Rice codification for the remainder. \n\n    Returns:\n        - string: natural binary string of the number.    \n    '''\n    bitsNaturalBinary = \"\"\n\n    if (num &lt; 0):                                                               # Check if the number is negative.\n        num *= -1                                                               # If so, we multiply it by - 1, to converti it to a positive value. \n\n    binaryNum = bin(num)                                                        # Convert the number to binary. \n\n    if (M != -1):                                                               # Check if we want to have a specific number of bits\n        zerosToAdd = M - len(binaryNum[2:])                                     # Calculate the number of zeros that we have to add.\n        for _ in range(zerosToAdd):                                             # Iterate through the zeros.\n            bitsNaturalBinary += \"0\"                                            # Add the zeros to te result.\n        bitsNaturalBinary += binaryNum[2:]                                      # Add the codification. \n    else:                                                                       # Otherwise,\n        bitsNaturalBinary = binaryNum[2:]                                       # Return the necessary bits for representing the natural binary. \n\n    return bitsNaturalBinary                                                    # Return the natural binary string of the number.\n</code></pre>"},{"location":"riceFunctions/#src.RiceFunctions.riceFunctions.calculateDecimalNumber","title":"<code>calculateDecimalNumber(binaryNum)</code>","text":"<p>Method to calculate the decimal number from a natural binary number.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>binaryNum(int</code> <p>Binary number to convert.</p> required <p>Returns     - decimalNum(int): The decimal number, converted from the binary number.</p> Source code in <code>src/RiceFunctions/riceFunctions.py</code> <pre><code>def calculateDecimalNumber(binaryNum):\n    '''\n    Method to calculate the decimal number from a natural binary number.\n\n    Args:\n        - binaryNum(int): Binary number to convert.\n\n    Returns\n        - decimalNum(int): The decimal number, converted from the binary number. \n    '''\n    return (int(binaryNum, 2))\n</code></pre>"},{"location":"riceFunctions/#src.RiceFunctions.riceFunctions.decodeRice","title":"<code>decodeRice(encodedNum, M)</code>","text":"<p>Method to decode the encoded number in Rice. </p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>encodedNum(int</code> <p>The number encoded with the Rice algorithm. </p> required <code>-</code> <code>M(int</code> <p>Integer value, power of 2, necessary to the encode. </p> required <p>Returns:</p> Type Description <ul> <li>finalNumber(int): The number decoded.</li> </ul> Source code in <code>src/RiceFunctions/riceFunctions.py</code> <pre><code>def decodeRice(encodedNum, M):\n    '''\n    Method to decode the encoded number in Rice. \n\n    Args:\n        - encodedNum(int): The number encoded with the Rice algorithm. \n        - M(int): Integer value, power of 2, necessary to the encode. \n\n    Returns: \n        - finalNumber(int): The number decoded. \n    '''\n    quotient = 0                                                                # Count the number of 1's, the quotient. \n    sign = encodedNum[0]                                                        # Read the first bit of the encoded number which is the sign. \n\n    for i in range(1, len(encodedNum)):                                         # Iterate from the first position to the end of the encoded number.\n        if (encodedNum[i] == \"1\"):                                              # If we read a 1.\n            quotient += 1                                                       # We sum 1 to the quotient. \n        else:                                                                   # Otherwise.\n            pos = i                                                             # Get the position where the remiander starts.\n            break                                                               # Break the loop by changing the value of the zeroFound variable. \n\n    remainder = calculateDecimalNumber(encodedNum[pos::])                       # Get the remainder number and convert it to decimal.\n    finalNumber = (quotient * M) + remainder                                    # Calculate the number. \n\n    if sign == 0:                                                               # Check the value of the sign. \n        finalNumber *= -1                                                       # If the value of the sign is 0, the number is negative. \n\n    return finalNumber                                                          # Return the final number\n</code></pre>"},{"location":"riceFunctions/#src.RiceFunctions.riceFunctions.encodeRice","title":"<code>encodeRice(M, num)</code>","text":"<p>Method to do the Roce codification. </p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>M(int</code> <p>Integer value, power of 2, necessary to the encode. </p> required <code>-</code> <code>num(int</code> <p>Number that we want to encode. </p> required <p>Returns:</p> Type Description <ul> <li>result(string): binary string with the codification.</li> </ul> Source code in <code>src/RiceFunctions/riceFunctions.py</code> <pre><code>def encodeRice(M, num):\n    '''\n    Method to do the Roce codification. \n\n    Args:\n        - M(int): Integer value, power of 2, necessary to the encode. \n        - num(int): Number that we want to encode. \n\n    Returns:\n        - result(string): binary string with the codification. \n    '''\n\n    result = \"\"                                                                 # Inicialize the codification of the number with the algorithm Rice as an empty string.\n\n    if (num &gt;= 0):                                                              # Check if the number is bigger or equal to 0. \n        sign = 1                                                                # We establish the sign bit as 1. We consider that 0 is a positive value. \n    else:                                                                       # If the number is smaller than 0, a negative number. \n        sign = 0                                                                # We establish the sign number as 0. \n\n    quotient = int(abs(num)/M)                                                  # Calculate the quotient. \n    remainder = (abs(num) % M)                                                  # Calculate the remainder. \n    result += str(sign)                                                         # We insert the sign to the result. \n\n    for _ in range(quotient):                                                   # Iterate in the quotient range.\n        result += \"1\"                                                           # We add as much 1's as the number of the quotient.\n\n    result += \"0\"                                                               # Add a final 0 to the codification of the quotient.\n    result += calculNaturalBinaryBits(remainder, int(math.log(M, 2)))           # Add the remainder to the result of the codification.\n\n    return result\n</code></pre>"}]}